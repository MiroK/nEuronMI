contact_volumes[] = {};
nrows=5;
conv = 0.0001;  // from um to cm              
y_shifts[] = {conv*(2+12+6), conv*(-1-6), conv*(1+6), conv*(-2-12-6)};
z_shifts[] = {conv*6, conv*6, conv*26, conv*26};

If(with_contacts)
  volume_counter = 0;
  // Contacts
  For col In {0:3}
      y_shift = y_shifts[col];
      z_shift = z_shifts[col];

      For i In {0:nrows}    
          cx = probe_x - 0.5*probe_thick;
          cy = probe_y+y_shift;
          cz = probe_z + 150*conv + i*40*conv + z_shift;

          square = newv;
          Box(square) = {cx, cy-contact_rad/2, cz-contact_rad/2, 0.1*conv, contact_rad, contact_rad};
    
          contact_volumes[] += {square};

          all_volumes[volume_counter] = square;
          volume_counter += 1;
      EndFor
  EndFor                                       
EndIf


// Bounding polygon
p = newp;
points[] = {5, p, p+1, p+2, p+3, p+4};
Point(points[1]) = {probe_x - probe_thick/2, probe_y, probe_z};
Point(points[2]) = {probe_x - probe_thick/2, probe_y+35*conv, probe_z+150*conv};
Point(points[3]) = {probe_x - probe_thick/2, probe_y+35*conv, probe_z+probe_top};
Point(points[4]) = {probe_x - probe_thick/2, probe_y-35*conv, probe_z+probe_top};
Point(points[5]) = {probe_x - probe_thick/2, probe_y-35*conv, probe_z+150*conv};

l = newl;
lines[] = {5, l, l+1, l+2, l+3, l+4};
Line(lines[1]) = {points[1], points[2]};
Line(lines[2]) = {points[2], points[3]};
Line(lines[3]) = {points[3], points[4]};
Line(lines[4]) = {points[4], points[5]};
Line(lines[5]) = {points[5], points[1]};

// The polygon
polyg = news;
// {133, 134, 135, 129, 130, 131, 132};
Line Loop(polyg) = {lines[4], lines[5], lines[1], lines[2], lines[3]};
Plane Surface(polyg) = {polyg};
v[] = Extrude {probe_thick, 0, 0} { Surface{polyg}; };
probe_free = v[1];
   
If(with_contacts)
  // Rotate
  Rotate {{0, 0, 1}, {probe_x, probe_y, probe_z}, rot_angle} {
   Volume{probe_free, contact_volumes[]};
  }

  bbox_probe() = BooleanDifference {Volume{bbox}; Delete;}{Volume{probe_free, all_volumes[]}; Delete;};
  outside() = BooleanDifference { Volume{bbox_probe}; Delete; }{ Volume{neuron};};
  Physical Volume(2) = {outside[]};  

  outside_surface() = Boundary{ Volume{outside()}; };

  Physical Surface(5) = {8, 9, 11, 12, 13};
  Physical Surface(6) = {10};

  probe_surface[] = outside_surface[];
  probe_surface[] -= {8, 9, 10, 11, 12, 13};  // outer
  probe_surface[] -= {1, 2, 3, 4, 5, 6, 7};       // neuron surfaces

  probe_insul_surface[] = {14:19};
  Physical Surface(4) = {probe_insul_surface[]};
  
  probe_contact_surface[] = probe_surface[];
  probe_contact_surface[] -= {probe_insul_surface[]};

  // Give probes their names
  ncontacts = #probe_contact_surface[];

  For i In {0:ncontacts-1}
      Physical Surface(41 + i) = {probe_contact_surface[i]};  
  EndFor
Else
  // Rotate
  Rotate {{0, 0, 1}, {probe_x, probe_y, probe_z}, rot_angle} {
    Volume{probe_free}; 
  } 

  bbox_probe() = BooleanDifference {Volume{bbox}; Delete;}{Volume{probe_free}; Delete;};

  outside() = BooleanDifference { Volume{bbox_probe}; Delete; }{ Volume{neuron};};
  // Physical
  Physical Volume(2) = {outside[]};  

  // Probe surfaces, no contact surface so no 41
  probe_surface[] = {14:67};
  Physical Surface(4) = {probe_surface[]};

  // Boundaries is of the 2 volume
  Physical Surface(5) = {8, 9, 11, 12, 13};
  Physical Surface(6) = {10};
EndIf
