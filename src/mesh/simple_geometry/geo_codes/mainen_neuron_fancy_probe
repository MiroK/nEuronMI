contact_volumes[] = {};
If(with_contacts)
  volume_counter = 0;
  // Contacts
  conv = 0.0001;  // from um to cm
  For i In {0:11}
    circle = newv;
    cx  = probe_x - 0.5*probe_thick;
    cy = probe_y;
    cz = probe_z + 62*conv + i*25*conv;
    //Cylinder(circle) = {cx, cy, cz, probe_thick, 0, 0, contact_rad};
    Cylinder(circle) = {cx, cy, cz, 0.1*conv, 0, 0, contact_rad};
    contact_volumes[] += {circle};
    
    all_volumes[volume_counter] = circle;
    volume_counter += 1;
  EndFor

  cz = 0;
  For i In {0:9}
    cx = probe_x - 0.5*probe_thick;
    cz = probe_z + 62*conv + Sqrt(22*22-18*18)*conv +i*25*conv;

    cy = probe_y + 18*conv;
    circle = newv;
    //Cylinder(circle) = {cx, cy, cz, probe_thick, 0, 0, contact_rad};
    Cylinder(circle) = {cx, cy, cz, 0.1*conv, 0, 0, contact_rad};
    contact_volumes[] += {circle};

    all_volumes[volume_counter] = circle;
    volume_counter += 1;

    //--------

    cy = probe_y - 18*conv;
    circle = newv;
    //Cylinder(circle) = {cx, cy, cz, probe_thick, 0, 0, contact_rad};
    Cylinder(circle) = {cx, cy, cz, 0.1*conv, 0, 0, contact_rad};
    contact_volumes[] += {circle};

    all_volumes[volume_counter] = circle;
    volume_counter += 1;
  EndFor
EndIf


// Bounding polygon
cz = 62*conv + Sqrt(22*22-18*18)*conv + 9*25*conv;
p = newp;
points[] = {7, p, p+1, p+2, p+3, p+4, p+5, p+6};
Point(points[1]) = {probe_x - probe_thick/2, probe_y, probe_z};
Point(points[2]) = {probe_x - probe_thick/2, probe_y+31*conv, probe_z+62*conv};
Point(points[3]) = {probe_x - probe_thick/2, probe_y+57*conv, probe_z+cz};
Point(points[4]) = {probe_x - probe_thick/2, probe_y+57*conv, probe_z+probe_top};
Point(points[5]) = {probe_x - probe_thick/2, probe_y-57*conv, probe_z+probe_top};
Point(points[6]) = {probe_x - probe_thick/2, probe_y-57*conv, probe_z+cz};
Point(points[7]) = {probe_x - probe_thick/2, probe_y-31*conv, probe_z+62*conv};

l = newl;
lines[] = {7, l, l+1, l+2, l+3, l+4, l+5, l+6};
Line(lines[1]) = {points[1], points[2]};
Line(lines[2]) = {points[2], points[3]};
Line(lines[3]) = {points[3], points[4]};
Line(lines[4]) = {points[4], points[5]};
Line(lines[5]) = {points[5], points[6]};
Line(lines[6]) = {points[6], points[7]};
Line(lines[7]) = {points[7], points[1]};

// The polygon
polyg = news;
// {133, 134, 135, 129, 130, 131, 132};
Line Loop(polyg) = {lines[5], lines[6], lines[7], lines[1], lines[2], lines[3], lines[4]};
Plane Surface(polyg) = {polyg};
v[] = Extrude {probe_thick, 0, 0} { Surface{polyg}; };
probe_free = v[1];


If(is_masked == 0)
If(with_contacts)
  // Rotate
  Rotate {{0, 0, 1}, {probe_x, probe_y, probe_z}, rot_angle} {
    Volume{probe_free, contact_volumes[]}; 
  } 

  bbox_probe() = BooleanDifference {Volume{bbox}; Delete;}{Volume{probe_free, all_volumes[]}; Delete;};
  outside() = BooleanDifference { Volume{bbox_probe}; Delete; }{ Volume{neuron};};
  Physical Volume(2) = {outside[]};  

  outside_surface() = Boundary{ Volume{outside()}; };

  Physical Surface(5) = {8, 9, 11, 12, 13};
  Physical Surface(6) = {10};

  probe_surface[] = outside_surface[];
  probe_surface[] -= {8, 9, 10, 11, 12, 13};  // outer
  probe_surface[] -= {1, 2, 3, 4, 5, 6, 7};       // neuron surfaces

  probe_insul_surface[] = {14:21};
  Physical Surface(4) = {probe_insul_surface[]};
  
  probe_contact_surface[] = probe_surface[];
  probe_contact_surface[] -= {probe_insul_surface[]};
  // Give probes their names
  ncontacts = #probe_contact_surface[];
  For i In {0:ncontacts-1}
      Physical Surface(41 + i) = {probe_contact_surface[i]};  
  EndFor

Else
  // Rotate
  Rotate {{0, 0, 1}, {probe_x, probe_y, probe_z}, rot_angle} {
    Volume{probe_free}; 
  } 

  bbox_probe() = BooleanDifference {Volume{bbox}; Delete;}{Volume{probe_free}; Delete;};

  outside() = BooleanDifference { Volume{bbox_probe}; Delete; }{ Volume{neuron};};
  // Physical
  Physical Volume(2) = {outside[]};  

  // Probe surfaces, no contact surface so no 41
  probe_surface[] = {14:21};
  Physical Surface(4) = {probe_surface[]};

  // Boundaries is of the 2 volume
  Physical Surface(5) = {8, 9, 11, 12, 13};
  Physical Surface(6) = {10};
EndIf
// No neuron
Else
If(with_contacts)
  // Rotate
  Rotate {{0, 0, 1}, {probe_x, probe_y, probe_z}, rot_angle} {
    Volume{probe_free, contact_volumes[]}; 
  } 

  outside() = BooleanDifference {Volume{bbox}; Delete;}{Volume{probe_free, all_volumes[]}; Delete;};
  Physical Volume(2) = {outside[]};  

  outside_surface() = Boundary{ Volume{outside()}; };
  neuron_surface[] = {};
  
  //Physical Surface(5) = {1, 2, 4, 5, 6};
  //Physical Surface(6) = {3};
  Physical Surface(5) = {108, 109, 111, 112, 113};
  Physical Surface(6) = {110};

  probe_surface[] = outside_surface[];
  //probe_surface[] -= {1, 2, 3, 4, 5, 6};  // outer
  probe_surface[] -= {108, 109, 110, 111, 112, 113};  // outer

  //probe_insul_surface[] = {7, 8, 9, 10, 11, 12, 13, 14};
  probe_insul_surface[] = {104, 105, 106, 107, 114, 115, 116, 117};
  Physical Surface(4) = {probe_insul_surface[]};
  
  probe_contact_surface[] = probe_surface[];
  probe_contact_surface[] -= {probe_insul_surface[]};
  // Give probes their names
  ncontacts = #probe_contact_surface[];
  For i In {0:ncontacts-1}
      Physical Surface(41 + i) = {probe_contact_surface[i]};  
  EndFor

Else
  // Rotate
  Rotate {{0, 0, 1}, {probe_x, probe_y, probe_z}, rot_angle} {
    Volume{probe_free}; 
  } 

  outside() = BooleanDifference {Volume{bbox}; Delete;}{Volume{probe_free}; Delete;};
  // Physical
  Physical Volume(2) = {outside[]};  

  // Probe surfaces, no contact surface so no 41
  neuron_surface[] = {};      
  probe_surface[] = {8, 9, 10, 11, 18, 19, 20, 21};
  Physical Surface(4) = {probe_surface[]};

  // Boundaries is of the 2 volume
  Physical Surface(5) = {12, 13, 15, 16, 17};
  Physical Surface(6) = {14};
EndIf

EndIf